# 转：集合 (set) 的增删改查及 copy()方法

## 简介：

#### 集合是无序的，不重复的数据集合，它里面的元素是可哈希的(不可变类型)，但是集合本身是不可哈希（所以集合做不了字典的键）的。以下是集合最重要的两点：

#### 1、去重，把一个列表变成集合，就自动去重了。

#### 2、关系测试，测试两组数据之前的交集、差集、并集等关系。

## 一、集合的创建

set1 = set({1,2,3,4,5})
set2 = {1,2,3,4,5}
set3 = set('abc')
print(set1,set2,set3)
\#{1, 2, 3, 4, 5} {1, 2, 3, 4, 5} {'c', 'b', 'a'}

## 二、添加集合元素的方法

**▷add( )方法：**

**此方法是用来往集合里添加单个元素，如果已存在，则不会添加。**

set1 = {1,2,3,4,5}
set1.add(6)
print(set1)
set1.add(1)
print(set1)

**▷update( )方法：**

**此方法是用来迭代的往集合里添加元素**

set1 = {1,2,3,4,5}
set1.update('6') #不能直接添加数字类型，因为数字类型不可迭代
print(set1) # {1, 2, 3, 4, 5, '6'}
set1.update('abc')
print(set1) #{1, 2, 3, 4, 5, 'c', 'a', '6', 'b'}
set1.update([1,7,8,9])
print(set1) #{1, 2, 3, 4, 5, 'b', 7, 8, 9, 'a', 'c', '6'}

 

## 三、删除集合元素的方法

set1 = {1,2,3,4,5}
et1.pop() #随机删除一个元素，将元素值返回
set1.remove('2') #指定删除一个元素，找不到就会报错
set1.clear() #清空整个集合
del set1 #删除整个集合

## 四、查询集合元素的方法

**由于集合是无序的又没有索引，所以查询集合元素只有一种，那就是循环，如下：**

set1 = {1,2,3,4,5}
for s in set1:
print(s)
\#结果如下：
\# 16 # 27 # 38 # 49 # 5

## 五、集合的交集、并集等

set1 = {1,2,3,7,8}
set2 = {2,3,6,9} 
print(set1&set2) #交集{2, 3} 
print(set1|set2) #并集{1, 2, 3, 6, 7, 8, 9}
print(set1^set2) #反交集{1, 6, 7, 8, 9}
print(set1-set2) #差集{8, 1, 7} 独有的
print(set2-set1) #差集{9, 6} 独有的
set1 = {1,2,3} #set1为set2的子集
set2 = {1,2,3,4,5} #set2为set1的超集

## 六、frozenset( )不可变集合（无法添加无法修改）

set1 = {1,2,3,4,5}
set2 = frozenset(set1)
print(set2,type(set2))
\#结果为：frozenset({1, 2, 3, 4, 5}) <class 'frozenset'>
\#创建方法如下：
set3 = frozenset({1,2,3})
print(set3) # frozenset({1, 2, 3})
set4 = frozenset('abc') #迭代添加
print(set4) # frozenset({'a', 'b', 'c'})

## 七、copy( )与 deepcopy（）

**这两种方法用于复制一个变量然后赋值给另一个变量。**

#### copy( )----浅复制

简单来讲，用此方法复制后的变量与原变量对应的内存地址是不一样的，修改它第一层的元素，另一个变量不会被修改

但是如果他们有嵌套（如列表里嵌套列表），那么第二层嵌套的列表与另一个变量所对应的列表的地址就是一个内存地址了，

这个时候，如果修改第二层的元素，则另一个变量也会被修改

**▷用法：**

a = ['a','b','c']
b = a.copy()
print(b)
\#结果为：['a', 'b', 'c']

 

**▷复制之后两个变量所对应的内存地址的问题：**

**先看赋值运算：**

**此时两个内存地址是一样的，更改一个列表的值，另一个也会被修改：如下：**

li1 = [1,2,[3,4],5]

 

 

 

 

 

**再看看copy方法：**

**此时他们的内存地是不同的，更改一个列表的第一层元素的值，另一个不会被更改，如下：**

li1 = [1,2,[3,4],5]
li2 = li1.copy()
print(li1 is li2) #False
li2[0] = 0 #更改li2第一层的值，li1不会被修改
print(li1) #[1, 2, [3, 4], 5]

 

**但是，如果我们要修改一个列表的第二层元素的话，另一个列表就会被修改了，如下：**

li1 = [1,2,[3,4],5]
li2 = li1.copy()
print(li1 is li2) #False
li2[2][0] = 0 #更改li2第二层的值，li1就会被修改
print(li1) #[1, 2, [0, 4], 5]

#### deepcopy( )----深复制

**简单来讲，用此方法复制后的变量与原变量对应的内存地址是不一样的，不管有没有嵌套，修改它第一层的元素，另一个变量不会被修改**

**但是用这个方法之前，必须得导入copy包，如下：**

import copy
li1 = [1,2,[3,4],5]
li2 = copy.deepcopy(li1)
print(li1 is li2) #False
li2[2][0] = 0 #更改li2第二层的值，li1也不会被修改
print(li1) #[1, 2, [3, 4], 5]

## 八、如何将一个列表里的重复元素去掉

**▷思路：将列表转换为集合，它会自动去重，然后再将集合转换为列表即可**

**▷代码：如下：**

li1 = [1,2,3,2,1,5,6,7,6,5,8]
set1 = set(li1)
li1 = list(set1)
print(li1) #结果为：[1, 2, 3, 5, 6, 7, 8]